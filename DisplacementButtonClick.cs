using Microsoft.MixedReality.Toolkit.Input;
using Microsoft.MixedReality.Toolkit.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;

public class Gauge : MonoBehaviour
{
    // id of each strain gauge given by the csv file
    // private int gaugeID;
    // value that will be passed along from the csv file
    // i.e. West Slip 1, East Slip 1
    // private string gaugeName;

    // If we get to heatmapping this will determine color
    // private Gradient gradient;
    
    // history of displacement potentially stored here for playback/debugging
    // public List<float> displacementHistory = new List<float>();

    // store initial coordinates and new coordinates to measure displacement
    // x positive goes east
    private float xStart;
    // y positive goes geographically up(North)
    private float yStart;
    // z positive goes up
    private float zStart;

    // x positive goes east
    private float xCurr;
    // y positive goes geographically up(North)
    private float yCurr;
    // z positive goes up
    private float zCurr;

    public Gauge(float x, float y, float z)
    {
        xStart = x;
        yStart = y;
        zStart = z;
    }

    public void updateGauge(float x, float y, float z)
    {
        xCurr = x;
        yCurr = y;
        zCurr = z;
        // displacement and calculations done here
        calcDisplacement();
        // calcSlipStrain();


    }

    public float calcDisplacement()
    {
        // displacement is in inches
        // still trying to find examples of displacement
        // And what data we will receive
        // would readout value change to display
        // for now I assume difference from starting position

        float displaceVal = xCurr - xStart;

        // displacementHistory.add(displaceVal);
        return displaceVal;
    }

    public float calcSlipStrain()
    {
        // eventually add this function into updateGauge() to calculate SlipStrain as well
        return slipStrainVal;
    }

    // if using heatmaps, this function would change gradient based on strain
    public changeGradient(Gradient newGradient)
    {
        return;
    }
    
}

public class DisplacementButtonClick : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        // Upon the button being clicked the gauges will be generated by the csv file

        // initialize an list to hold id's of the objects created
        // c# friendly list
        // assuming only around 8~ gauges will be held from test data, can be modified
        public List<Gauge> gauges = new List<Gauge>();

        // amount of gauges we are reading data from, assuming it will be 8 for now
        // private int gaugeCount = 0;
        private int gaugeCount = 8;
        
        // int readInValue;
        // read in amount of gauges
        // read function to see how many gauges there are
        // gaugeCount = readInValue;

        for (int i = 0; i < gaugeCount; i++)
        {
            // find out if this process can be multithreaded for each gauge added
            // i.e. use openMP for each gauge created
            // set threads from here then pass how many threads

            // potentially read in gaugeName for debugging output
            // string tempName = fromCsv();

            // potentially read in gaugeID for debugging output
            // int tempID = fromCsv();        

            // read in coordinates of the gauges in the object
            float tempX = 0;
            float tempY = 0;
            float tempZ = 0;

            // read in values for x,y,z
            // tempX = fromCsv();
            // tempY = fromCsv();
            // tempZ = fromCsv();

            // create objects representing new gauge
            // place respective to x(East),y(North),z(Up)
            // should tempName/gaugeID be added, add it to constructor and calls
            Gauge newGauge = new Gauge(x, y, z);

            // add newGauge to our list of gauges
            gauges.add(newGauge);
            
            // most likely split this script into two parts
            // in order to give each gauge a script that then updates
            // similar to the prototype anphong made last term
        }
    }

    // Update is called once per frame
    void Update()
    {
        // feeding in information from csv file

        // need to know syntax for while button is clicked

        // Take information that has been given and update each corresponding gauge
        // once consensus on csv file is made, add respective units to this.
        // i.e. updateGauge(float x, float y, float z);
        updateGauge();
    }

}
